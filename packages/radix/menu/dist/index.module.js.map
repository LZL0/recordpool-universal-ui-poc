{"mappings":"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","sources":["./packages/react/menu/src/useMenuTypeahead.tsx","./packages/react/menu/src/Menu.tsx"],"sourcesContent":["import * as React from 'react';\n\nfunction useMenuTypeahead() {\n  const timerRef = React.useRef(0);\n  const searchRef = React.useRef('');\n\n  // Reset `searchRef` 1 second after it was last updated\n  const setSearch = React.useCallback((search: string) => {\n    searchRef.current = search;\n    window.clearTimeout(timerRef.current);\n    timerRef.current = window.setTimeout(() => setSearch(''), 1000);\n  }, []);\n\n  return {\n    onKeyDownCapture: (event: React.KeyboardEvent) => {\n      if (event.key.length === 1 && !(event.ctrlKey || event.altKey || event.metaKey)) {\n        const container = event.currentTarget as HTMLElement;\n        setSearch(searchRef.current + event.key);\n\n        // Stop activating the item if we're still \"searching\", essentially preventing\n        // the spacebar from selecting the item currently focused.\n        // This is also why we use `onKeyDownCapture` rather than `onKeyDown`\n        if (event.key === ' ' && !searchRef.current.startsWith(' ')) {\n          event.stopPropagation();\n        }\n\n        const currentItem = document.activeElement;\n        const currentMatch = currentItem ? getValue(currentItem) : undefined;\n        const values = Array.from(container.querySelectorAll(`[${ITEM_ATTR}]`)).map(getValue);\n        const nextMatch = getNextMatch(values, searchRef.current, currentMatch);\n        const newItem = container.querySelector(`[${ITEM_ATTR}=\"${nextMatch}\"]`);\n\n        if (newItem) {\n          /**\n           * Imperative focus during keydown is risky so we prevent React's batching updates\n           * to avoid potential bugs. See: https://github.com/facebook/react/issues/20332\n           */\n          setTimeout(() => (newItem as HTMLElement).focus());\n        }\n      }\n    },\n  };\n}\n\n/**\n * This is the \"meat\" of the matching logic. It takes in all the values,\n * the search and the current match, and returns the next match (or `undefined`).\n *\n * We normalize the search because if a user has repeatedly pressed a character,\n * we want the exact same behavior as if we only had that one character\n * (ie. cycle through options starting with that character)\n *\n * We also reorder the values by wrapping the array around the current match.\n * This is so we always look forward from the current match, and picking the first\n * match will always be the correct one.\n *\n * Finally, if the normalized search is exactly one character, we exclude the\n * current match from the values because otherwise it would be the first to match always\n * and focus would never move. This is as opposed to the regular case, where we\n * don't want focus to move if the current match still matches.\n */\nfunction getNextMatch(values: string[], search: string, currentMatch?: string) {\n  const isRepeated = search.length > 1 && Array.from(search).every((char) => char === search[0]);\n  const normalizedSearch = isRepeated ? search[0] : search;\n  const currentMatchIndex = currentMatch ? values.indexOf(currentMatch) : -1;\n  let wrappedValues = wrapArray(values, Math.max(currentMatchIndex, 0));\n  const excludeCurrentMatch = normalizedSearch.length === 1;\n  if (excludeCurrentMatch) wrappedValues = wrappedValues.filter((v) => v !== currentMatch);\n  const nextMatch = wrappedValues.find((value) =>\n    value.toLowerCase().startsWith(normalizedSearch.toLowerCase())\n  );\n  return nextMatch !== currentMatch ? nextMatch : undefined;\n}\n\nconst getValue = (element: Element) => element.getAttribute(ITEM_ATTR) ?? '';\n\nconst ITEM_ATTR = 'data-radix-menu-typeahead-item';\n\ntype UseMenuTypeaheadItemOptions = { textValue: string; disabled?: boolean };\n\nfunction useMenuTypeaheadItem({ textValue, disabled }: UseMenuTypeaheadItemOptions) {\n  return { [ITEM_ATTR]: disabled ? undefined : textValue };\n}\n\n/**\n * Wraps an array around itself at a given start index\n * Example: `wrapArray(['a', 'b', 'c', 'd'], 2) === ['c', 'd', 'a', 'b']`\n */\nfunction wrapArray<T>(array: T[], startIndex: number) {\n  return array.map((_, index) => array[(startIndex + index) % array.length]);\n}\n\nexport { useMenuTypeahead, useMenuTypeaheadItem };\n","import * as React from 'react';\nimport { Platform, View } from 'react-native';\nimport { RemoveScroll } from 'react-remove-scroll';\nimport { hideOthers } from 'aria-hidden';\nimport { composeEventHandlers } from '@radix-ui/primitive';\nimport { createCollection } from '@radix-ui/react-collection';\nimport { useComposedRefs } from '@radix-ui/react-compose-refs';\nimport { createContext } from '@radix-ui/react-context';\nimport { DismissableLayer } from '@radix-ui/react-dismissable-layer';\nimport { FocusScope } from '@radix-ui/react-focus-scope';\nimport { Presence } from '@radix-ui/react-presence';\nimport { Primitive, extendPrimitive } from '@radix-ui/react-primitive';\nimport * as PopperPrimitive from '@radix-ui/react-popper';\nimport { Portal } from '@radix-ui/react-portal';\nimport { RovingFocusGroup, RovingFocusItem } from '@radix-ui/react-roving-focus';\nimport { Slot } from '@radix-ui/react-slot';\nimport { useCallbackRef } from '@radix-ui/react-use-callback-ref';\nimport { useFocusGuards } from '@radix-ui/react-focus-guards';\nimport { useMenuTypeahead, useMenuTypeaheadItem } from './useMenuTypeahead';\n\nimport type * as Polymorphic from '@radix-ui/react-polymorphic';\n\nconst FIRST_KEYS = ['ArrowDown', 'PageUp', 'Home'];\nconst LAST_KEYS = ['ArrowUp', 'PageDown', 'End'];\nconst ALL_KEYS = [...FIRST_KEYS, ...LAST_KEYS];\n\n/* -------------------------------------------------------------------------------------------------\n * Menu\n * -----------------------------------------------------------------------------------------------*/\n\nconst MENU_NAME = 'Menu';\n\ntype MenuContextValue = {\n  open: boolean;\n  onOpenChange(open: boolean): void;\n};\n\nconst [MenuProvider, useMenuContext] = createContext<MenuContextValue>(MENU_NAME);\n\ntype MenuOwnProps = {\n  open?: boolean;\n  onOpenChange?(open: boolean): void;\n};\n\nconst Menu: React.FC<MenuOwnProps> = (props) => {\n  const { open = false, children, onOpenChange } = props;\n  const handleOpenChange = useCallbackRef(onOpenChange);\n  return (\n    <PopperPrimitive.Root>\n      <MenuProvider open={open} onOpenChange={handleOpenChange}>\n        {children}\n      </MenuProvider>\n    </PopperPrimitive.Root>\n  );\n};\n\nMenu.displayName = MENU_NAME;\n\n/* -------------------------------------------------------------------------------------------------\n * MenuContent\n * -----------------------------------------------------------------------------------------------*/\n\nconst CONTENT_NAME = 'MenuContent';\n\ntype ItemData = { disabled: boolean };\nconst [CollectionSlot, CollectionItemSlot, useCollection] = createCollection<\n  React.ElementRef<typeof MenuItem>,\n  ItemData\n>();\n\ntype MenuContentContextValue = { onItemLeave(): void };\nconst [MenuContentProvider, useMenuContentContext] = createContext<MenuContentContextValue>(\n  CONTENT_NAME\n);\n\ntype MenuContentOwnProps = Polymorphic.Merge<\n  Polymorphic.OwnProps<typeof MenuContentImpl>,\n  {\n    /**\n     * Used to force mounting when more control is needed. Useful when\n     * controlling animation with React animation libraries.\n     */\n    forceMount?: true;\n  }\n>;\n\ntype MenuContentPrimitive = Polymorphic.ForwardRefComponent<\n  Polymorphic.IntrinsicElement<typeof MenuContentImpl>,\n  MenuContentOwnProps\n>;\n\nconst MenuContent = React.forwardRef((props, forwardedRef) => {\n  const { forceMount, ...contentProps } = props;\n  const context = useMenuContext(CONTENT_NAME);\n  return (\n    <Presence present={forceMount || context.open}>\n      <CollectionSlot>\n        <MenuContentImpl\n          data-state={getOpenState(context.open)}\n          {...contentProps}\n          ref={forwardedRef}\n        />\n      </CollectionSlot>\n    </Presence>\n  );\n}) as MenuContentPrimitive;\n\ntype FocusScopeOwnProps = Polymorphic.OwnProps<typeof FocusScope>;\ntype DismissableLayerOwnProps = Polymorphic.OwnProps<typeof DismissableLayer>;\ntype RovingFocusGroupOwnProps = Polymorphic.OwnProps<typeof RovingFocusGroup>;\n\ntype MenuContentImplOwnProps = Polymorphic.Merge<\n  Polymorphic.OwnProps<typeof PopperPrimitive.Content>,\n  Omit<DismissableLayerOwnProps, 'onDismiss'> & {\n    /**\n     * Whether focus should be trapped within the `MenuContent`\n     * (default: false)\n     */\n    trapFocus?: FocusScopeOwnProps['trapped'];\n\n    /**\n     * Event handler called when auto-focusing on open.\n     * Can be prevented.\n     */\n    onOpenAutoFocus?: FocusScopeOwnProps['onMountAutoFocus'];\n\n    /**\n     * Event handler called when auto-focusing on close.\n     * Can be prevented.\n     */\n    onCloseAutoFocus?: FocusScopeOwnProps['onUnmountAutoFocus'];\n\n    /**\n     * Whether scrolling outside the `MenuContent` should be prevented\n     * (default: `false`)\n     */\n    disableOutsideScroll?: boolean;\n\n    /**\n     * The direction of navigation between menu items.\n     * @defaultValue ltr\n     */\n    dir?: RovingFocusGroupOwnProps['dir'];\n\n    /**\n     * Whether keyboard navigation should loop around\n     * @defaultValue false\n     */\n    loop?: RovingFocusGroupOwnProps['loop'];\n\n    /**\n     * Whether the `MenuContent` should render in a `Portal`\n     * (default: `true`)\n     */\n    portalled?: boolean;\n  }\n>;\n\ntype MenuContentImplPrimitive = Polymorphic.ForwardRefComponent<\n  Polymorphic.IntrinsicElement<typeof PopperPrimitive.Content>,\n  MenuContentImplOwnProps\n>;\n\nconst MenuContentImpl = React.forwardRef((props, forwardedRef) => {\n  const {\n    dir = 'ltr',\n    loop = false,\n    trapFocus,\n    onOpenAutoFocus,\n    onCloseAutoFocus,\n    disableOutsidePointerEvents,\n    onEscapeKeyDown,\n    onPointerDownOutside,\n    onFocusOutside,\n    onInteractOutside,\n    disableOutsideScroll,\n    portalled,\n    ...contentProps\n  } = props;\n  const context = useMenuContext(CONTENT_NAME);\n  const typeaheadProps = useMenuTypeahead();\n  const { getItems } = useCollection();\n  const [currentItemId, setCurrentItemId] = React.useState<string | null>(null);\n  const [skipCloseAutoFocus, setSkipCloseAutoFocus] = React.useState(false);\n  const contentRef = React.useRef<HTMLDivElement>(null);\n  const composedRefs = useComposedRefs(forwardedRef, contentRef);\n\n  const PortalWrapper = portalled ? Portal : React.Fragment;\n  const ScrollLockWrapper = disableOutsideScroll ? RemoveScroll : React.Fragment;\n\n  // Make sure the whole tree has focus guards as our `MenuContent` may be\n  // the last element in the DOM (beacuse of the `Portal`)\n  useFocusGuards();\n\n  // Hide everything from ARIA except the `MenuContent`\n  React.useEffect(() => {\n    const content = contentRef.current;\n    if (content) return hideOthers(content);\n  }, []);\n\n  return (\n    <PortalWrapper>\n      <ScrollLockWrapper>\n        <MenuContentProvider\n          onItemLeave={React.useCallback(() => {\n            contentRef.current?.focus();\n            setCurrentItemId(null);\n          }, [])}\n        >\n          <FocusScope\n            as={Slot}\n            // we make sure we're not trapping once it's been closed\n            // (closed !== unmounted when animating out)\n            trapped={trapFocus && context.open}\n            onMountAutoFocus={onOpenAutoFocus}\n            onUnmountAutoFocus={(event) => {\n              // skip autofocus on unmount if clicking outside is permitted and it happened\n              if (skipCloseAutoFocus) {\n                event.preventDefault();\n              } else {\n                onCloseAutoFocus?.(event);\n              }\n            }}\n          >\n            <DismissableLayer\n              as={Slot}\n              disableOutsidePointerEvents={disableOutsidePointerEvents}\n              onEscapeKeyDown={composeEventHandlers(onEscapeKeyDown, () => {\n                setSkipCloseAutoFocus(false);\n              })}\n              onPointerDownOutside={composeEventHandlers(\n                onPointerDownOutside,\n                (event) => {\n                  const originalEvent = event.detail.originalEvent as MouseEvent;\n                  const isLeftClick = originalEvent.button === 0 && originalEvent.ctrlKey === false;\n                  setSkipCloseAutoFocus(!disableOutsidePointerEvents && isLeftClick);\n                },\n                { checkForDefaultPrevented: false }\n              )}\n              onFocusOutside={composeEventHandlers(\n                onFocusOutside,\n                (event) => {\n                  // When focus is trapped, a focusout event may still happen.\n                  // We make sure we don't trigger our `onDismiss` in such case.\n                  if (trapFocus) event.preventDefault();\n                },\n                { checkForDefaultPrevented: false }\n              )}\n              onInteractOutside={onInteractOutside}\n              onDismiss={() => context.onOpenChange(false)}\n            >\n              <RovingFocusGroup\n                as={Slot}\n                dir={dir}\n                orientation=\"vertical\"\n                loop={loop}\n                currentTabStopId={currentItemId}\n                onCurrentTabStopIdChange={setCurrentItemId}\n                // we override the default behaviour which automatically focuses the first item\n                onEntryFocus={(event) => event.preventDefault()}\n              >\n                <PopperPrimitive.Content\n                  role=\"menu\"\n                  {...contentProps}\n                  ref={composedRefs}\n                  style={{ outline: 'none', ...contentProps.style }}\n                  onKeyDownCapture={composeEventHandlers(\n                    contentProps.onKeyDownCapture,\n                    typeaheadProps.onKeyDownCapture\n                  )}\n                  // focus first/last item based on key pressed\n                  onKeyDown={composeEventHandlers(contentProps.onKeyDown, (event) => {\n                    const content = contentRef.current;\n                    if (event.target !== content) return;\n                    if (!ALL_KEYS.includes(event.key)) return;\n                    event.preventDefault();\n                    const items = getItems().filter((item) => !item.disabled);\n                    const candidateNodes = items.map((item) => item.ref.current!);\n                    if (LAST_KEYS.includes(event.key)) candidateNodes.reverse();\n                    focusFirst(candidateNodes);\n                  })}\n                />\n              </RovingFocusGroup>\n            </DismissableLayer>\n          </FocusScope>\n        </MenuContentProvider>\n      </ScrollLockWrapper>\n    </PortalWrapper>\n  );\n}) as MenuContentImplPrimitive;\n\nMenuContent.displayName = CONTENT_NAME;\n\n/* -------------------------------------------------------------------------------------------------\n * MenuItem\n * -----------------------------------------------------------------------------------------------*/\n\nconst ITEM_NAME = 'MenuItem';\nconst ITEM_DEFAULT_TAG = 'div';\nconst ITEM_SELECT = 'menu.itemSelect';\n\ntype MenuItemOwnProps = Polymorphic.Merge<\n  Omit<Polymorphic.OwnProps<typeof RovingFocusItem>, 'focusable' | 'active'>,\n  {\n    disabled?: boolean;\n    textValue?: string;\n    onSelect?: (event: Event) => void;\n  }\n>;\n\ntype MenuItemPrimitive = Polymorphic.ForwardRefComponent<typeof ITEM_DEFAULT_TAG, MenuItemOwnProps>;\n\nconst MenuItem = React.forwardRef((props, forwardedRef) => {\n  const { as = ITEM_DEFAULT_TAG, disabled = false, textValue, onSelect, ...itemProps } = props;\n  const ref = React.useRef<HTMLDivElement>(null);\n  const composedRefs = useComposedRefs(forwardedRef, ref);\n  const context = useMenuContext(ITEM_NAME);\n  const contentContext = useMenuContentContext(ITEM_NAME);\n\n  // get the item's `.textContent` as default strategy for typeahead `textValue`\n  const [textContent, setTextContent] = React.useState('');\n  React.useEffect(() => {\n    const menuItem = ref.current;\n    if (menuItem) {\n      setTextContent((menuItem.textContent ?? '').trim());\n    }\n  }, [itemProps.children]);\n\n  const menuTypeaheadItemProps = useMenuTypeaheadItem({\n    textValue: textValue ?? textContent,\n    disabled,\n  });\n\n  const handleSelect = () => {\n    const menuItem = ref.current;\n    if (!disabled && menuItem) {\n      const itemSelectEvent = new Event(ITEM_SELECT, { bubbles: true, cancelable: true });\n      menuItem.dispatchEvent(itemSelectEvent);\n      if (itemSelectEvent.defaultPrevented) return;\n      context.onOpenChange?.(false);\n    }\n  };\n\n  React.useEffect(() => {\n    const menuItem = ref.current;\n    if (menuItem) {\n      const handleItemSelect = (event: Event) => onSelect?.(event);\n      menuItem.addEventListener(ITEM_SELECT, handleItemSelect);\n      return () => menuItem.removeEventListener(ITEM_SELECT, handleItemSelect);\n    }\n  }, [onSelect]);\n\n  return (\n    <CollectionItemSlot disabled={disabled}>\n      <RovingFocusItem\n        role=\"menuitem\"\n        aria-disabled={disabled || undefined}\n        focusable={!disabled}\n        {...itemProps}\n        {...menuTypeaheadItemProps}\n        as={as}\n        ref={composedRefs}\n        data-disabled={disabled ? '' : undefined}\n        onKeyDown={composeEventHandlers(props.onKeyDown, (event) => {\n          if (!disabled && (event.key === 'Enter' || event.key === ' ')) {\n            // prevent page scroll if using the space key to select an item\n            if (event.key === ' ') event.preventDefault();\n            handleSelect();\n          }\n        })}\n        // we handle selection on `mouseUp` rather than `click` to match native menus implementation\n        onMouseUp={composeEventHandlers(props.onMouseUp, handleSelect)}\n        /**\n         * We focus items on `mouseMove` to achieve the following:\n         *\n         * - Mouse over an item (it focuses)\n         * - Leave mouse where it is and use keyboard to focus a different item\n         * - Wiggle mouse without it leaving previously focused item\n         * - Previously focused item should re-focus\n         *\n         * If we used `mouseOver`/`mouseEnter` it would not re-focus when the mouse\n         * wiggles. This is to match native menu implementation.\n         */\n        onMouseMove={composeEventHandlers(props.onMouseMove, (event) => {\n          if (!disabled) {\n            const item = event.currentTarget;\n            item.focus();\n          } else {\n            contentContext.onItemLeave();\n          }\n        })}\n        onMouseLeave={composeEventHandlers(props.onMouseLeave, () => contentContext.onItemLeave())}\n      />\n    </CollectionItemSlot>\n  );\n}) as MenuItemPrimitive;\n\nMenuItem.displayName = ITEM_NAME;\n\n/* -------------------------------------------------------------------------------------------------\n * MenuItemNative\n * -----------------------------------------------------------------------------------------------*/\n\nconst MenuItemNative = React.forwardRef((props, forwardedRef) => {\n  const { ...itemProps } = props;\n\n  return <View {...itemProps} ref={forwardedRef} />;\n}) as MenuItemPrimitive;\n\nMenuItemNative.displayName = ITEM_NAME;\n\n/* -------------------------------------------------------------------------------------------------\n * MenuCheckboxItem\n * -----------------------------------------------------------------------------------------------*/\n\nconst CHECKBOX_ITEM_NAME = 'MenuCheckboxItem';\n\ntype MenuCheckboxItemOwnProps = Polymorphic.Merge<\n  Polymorphic.OwnProps<typeof MenuItem>,\n  {\n    checked?: boolean;\n    onCheckedChange?: (checked: boolean) => void;\n  }\n>;\n\ntype MenuCheckboxItemPrimitive = Polymorphic.ForwardRefComponent<\n  Polymorphic.IntrinsicElement<typeof MenuItem>,\n  MenuCheckboxItemOwnProps\n>;\n\nconst MenuCheckboxItem = React.forwardRef((props, forwardedRef) => {\n  const { checked = false, onCheckedChange, ...checkboxItemProps } = props;\n  return (\n    <ItemIndicatorContext.Provider value={checked}>\n      <MenuItem\n        role=\"menuitemcheckbox\"\n        aria-checked={checked}\n        {...checkboxItemProps}\n        ref={forwardedRef}\n        data-state={getCheckedState(checked)}\n        onSelect={composeEventHandlers(\n          checkboxItemProps.onSelect,\n          () => onCheckedChange?.(!checked),\n          { checkForDefaultPrevented: false }\n        )}\n      />\n    </ItemIndicatorContext.Provider>\n  );\n}) as MenuCheckboxItemPrimitive;\n\nMenuCheckboxItem.displayName = CHECKBOX_ITEM_NAME;\n\n/* -------------------------------------------------------------------------------------------------\n * MenuRadioGroup\n * -----------------------------------------------------------------------------------------------*/\n\nconst RADIO_GROUP_NAME = 'MenuRadioGroup';\n\nconst RadioGroupContext = React.createContext<MenuRadioGroupOwnProps>({} as any);\n\ntype MenuRadioGroupOwnProps = Polymorphic.Merge<\n  Polymorphic.OwnProps<typeof MenuGroup>,\n  {\n    value?: string;\n    onValueChange?: (value: string) => void;\n  }\n>;\n\ntype MenuRadioGroupPrimitive = Polymorphic.ForwardRefComponent<\n  Polymorphic.IntrinsicElement<typeof MenuGroup>,\n  MenuRadioGroupOwnProps\n>;\n\nconst MenuRadioGroup = React.forwardRef((props, forwardedRef) => {\n  const { value, onValueChange, ...groupProps } = props;\n  const handleValueChange = useCallbackRef(onValueChange);\n  const context = React.useMemo(() => ({ value, onValueChange: handleValueChange }), [\n    value,\n    handleValueChange,\n  ]);\n  return (\n    <RadioGroupContext.Provider value={context}>\n      <MenuGroup {...groupProps} ref={forwardedRef} />\n    </RadioGroupContext.Provider>\n  );\n}) as MenuRadioGroupPrimitive;\n\nMenuRadioGroup.displayName = RADIO_GROUP_NAME;\n\n/* -------------------------------------------------------------------------------------------------\n * MenuRadioItem\n * -----------------------------------------------------------------------------------------------*/\n\nconst RADIO_ITEM_NAME = 'MenuRadioItem';\n\ntype MenuRadioItemOwnProps = Polymorphic.Merge<\n  Polymorphic.OwnProps<typeof MenuItem>,\n  { value: string }\n>;\ntype MenuRadioItemPrimitive = Polymorphic.ForwardRefComponent<\n  Polymorphic.IntrinsicElement<typeof MenuItem>,\n  MenuRadioItemOwnProps\n>;\n\nconst MenuRadioItem = React.forwardRef((props, forwardedRef) => {\n  const { value, ...radioItemProps } = props;\n  const context = React.useContext(RadioGroupContext);\n  const checked = value === context.value;\n  return (\n    <ItemIndicatorContext.Provider value={checked}>\n      <MenuItem\n        role=\"menuitemradio\"\n        aria-checked={checked}\n        {...radioItemProps}\n        ref={forwardedRef}\n        data-state={getCheckedState(checked)}\n        onSelect={composeEventHandlers(\n          radioItemProps.onSelect,\n          () => context.onValueChange?.(value),\n          { checkForDefaultPrevented: false }\n        )}\n      />\n    </ItemIndicatorContext.Provider>\n  );\n}) as MenuRadioItemPrimitive;\n\nMenuRadioItem.displayName = RADIO_ITEM_NAME;\n\n/* -------------------------------------------------------------------------------------------------\n * MenuItemIndicator\n * -----------------------------------------------------------------------------------------------*/\n\nconst ITEM_INDICATOR_NAME = 'MenuItemIndicator';\nconst ITEM_INDICATOR_DEFAULT_TAG = 'span';\n\nconst ItemIndicatorContext = React.createContext(false);\n\ntype MenuItemIndicatorOwnProps = Polymorphic.Merge<\n  Polymorphic.OwnProps<typeof Primitive>,\n  {\n    /**\n     * Used to force mounting when more control is needed. Useful when\n     * controlling animation with React animation libraries.\n     */\n    forceMount?: true;\n  }\n>;\n\ntype MenuItemIndicatorPrimitive = Polymorphic.ForwardRefComponent<\n  typeof ITEM_INDICATOR_DEFAULT_TAG,\n  MenuItemIndicatorOwnProps\n>;\n\nconst MenuItemIndicator = React.forwardRef((props, forwardedRef) => {\n  const { as = ITEM_INDICATOR_DEFAULT_TAG, forceMount, ...indicatorProps } = props;\n  const checked = React.useContext(ItemIndicatorContext);\n  return (\n    <Presence present={forceMount || checked}>\n      <Primitive\n        {...indicatorProps}\n        as={as}\n        ref={forwardedRef}\n        data-state={getCheckedState(checked)}\n      />\n    </Presence>\n  );\n}) as MenuItemIndicatorPrimitive;\n\nMenuItemIndicator.displayName = ITEM_INDICATOR_NAME;\n\n/* ---------------------------------------------------------------------------------------------- */\n\nconst MenuAnchor = extendPrimitive(PopperPrimitive.Anchor, { displayName: 'MenuAnchor' });\nconst MenuGroup = extendPrimitive(Primitive, {\n  defaultProps: { role: 'group' },\n  displayName: 'MenuGroup',\n});\nconst MenuLabel = extendPrimitive(Primitive, { displayName: 'MenuLabel' });\nconst MenuSeparator = extendPrimitive(Primitive, {\n  defaultProps: { role: 'separator', 'aria-orientation': 'horizontal' },\n  displayName: 'MenuSeparator ',\n});\nconst MenuArrow = extendPrimitive(PopperPrimitive.Arrow, { displayName: 'MenuArrow' });\n\n/* -----------------------------------------------------------------------------------------------*/\n\nfunction getOpenState(open: boolean) {\n  return open ? 'open' : 'closed';\n}\n\nfunction getCheckedState(checked: boolean) {\n  return checked ? 'checked' : 'unchecked';\n}\n\nfunction focusFirst(candidates: HTMLElement[]) {\n  const PREVIOUSLY_FOCUSED_ELEMENT = document.activeElement;\n  for (const candidate of candidates) {\n    // if focus is already where we want to go, we don't want to keep going through the candidates\n    if (candidate === PREVIOUSLY_FOCUSED_ELEMENT) return;\n    candidate.focus();\n    if (document.activeElement !== PREVIOUSLY_FOCUSED_ELEMENT) return;\n  }\n}\n\nconst Root = Menu;\nconst Anchor = MenuAnchor;\nconst Content = MenuContent;\nconst Group = MenuGroup;\nconst Label = MenuLabel;\nconst Item = Platform.OS === 'web' ? MenuItem : MenuItemNative;\nconst CheckboxItem = MenuCheckboxItem;\nconst RadioGroup = MenuRadioGroup;\nconst RadioItem = MenuRadioItem;\nconst ItemIndicator = MenuItemIndicator;\nconst Separator = MenuSeparator;\nconst Arrow = MenuArrow;\n\nexport {\n  Menu,\n  MenuAnchor,\n  MenuContent,\n  MenuGroup,\n  MenuLabel,\n  MenuItem,\n  MenuCheckboxItem,\n  MenuRadioGroup,\n  MenuRadioItem,\n  MenuItemIndicator,\n  MenuSeparator,\n  MenuArrow,\n  //\n  Root,\n  Anchor,\n  Content,\n  Group,\n  Label,\n  Item,\n  CheckboxItem,\n  RadioGroup,\n  RadioItem,\n  ItemIndicator,\n  Separator,\n  Arrow,\n};\nexport type {\n  MenuContentPrimitive,\n  MenuItemPrimitive,\n  MenuCheckboxItemPrimitive,\n  MenuRadioGroupPrimitive,\n  MenuRadioItemPrimitive,\n  MenuItemIndicatorPrimitive,\n};\n"],"names":["useMenuTypeahead","timerRef","React","useRef","searchRef","setSearch","useCallback","search","current","window","clearTimeout","setTimeout","onKeyDownCapture","event","key","length","ctrlKey","altKey","metaKey","container","currentTarget","startsWith","stopPropagation","currentItem","document","activeElement","currentMatch","getValue","undefined","nextMatch","values","normalizedSearch","Array","from","every","char","currentMatchIndex","indexOf","wrappedValues","array","startIndex","Math","max","map","_","index","filter","v","find","value","toLowerCase","getNextMatch","querySelectorAll","ITEM_ATTR","newItem","querySelector","focus","element","_element$getAttribute","getAttribute","LAST_KEYS","ALL_KEYS","MenuProvider","useMenuContext","createContext","Menu","props","open","children","onOpenChange","handleOpenChange","useCallbackRef","_react","createElement","_radixUiReactPopper","Root","$e9e2cf92950df0b951e7bac95d18$var$MenuProvider","CollectionSlot","CollectionItemSlot","useCollection","createCollection","MenuContentProvider","useMenuContentContext","MenuContent","forwardRef","forwardedRef","forceMount","contentProps","context","Presence","present","$e9e2cf92950df0b951e7bac95d18$var$CollectionSlot","$e9e2cf92950df0b951e7bac95d18$var$MenuContentImpl","_babelRuntimeHelpersEsmExtends","data-state","ref","MenuContentImpl","dir","loop","trapFocus","onOpenAutoFocus","onCloseAutoFocus","disableOutsidePointerEvents","onEscapeKeyDown","onPointerDownOutside","onFocusOutside","onInteractOutside","disableOutsideScroll","portalled","typeaheadProps","$d5f118c61d28e2c75ed88b93df338dde$export$useMenuTypeahead","getItems","currentItemId","setCurrentItemId","useState","skipCloseAutoFocus","setSkipCloseAutoFocus","contentRef","composedRefs","useComposedRefs","PortalWrapper","Portal","Fragment","ScrollLockWrapper","RemoveScroll","useFocusGuards","useEffect","content","hideOthers","$e9e2cf92950df0b951e7bac95d18$var$MenuContentProvider","onItemLeave","_contentRef$current","FocusScope","as","Slot","trapped","onMountAutoFocus","onUnmountAutoFocus","preventDefault","DismissableLayer","composeEventHandlers","originalEvent","detail","isLeftClick","button","checkForDefaultPrevented","onDismiss","RovingFocusGroup","orientation","currentTabStopId","onCurrentTabStopIdChange","onEntryFocus","Content","role","style","outline","onKeyDown","target","includes","candidateNodes","item","disabled","reverse","candidates","PREVIOUSLY_FOCUSED_ELEMENT","candidate","focusFirst","ITEM_DEFAULT_TAG","MenuItem","textValue","onSelect","itemProps","contentContext","textContent","setTextContent","menuItem","_menuItem$textContent","trim","menuTypeaheadItemProps","[object Object]","$d5f118c61d28e2c75ed88b93df338dde$export$useMenuTypeaheadItem","handleSelect","_context$onOpenChange","itemSelectEvent","Event","bubbles","cancelable","dispatchEvent","defaultPrevented","call","handleItemSelect","addEventListener","removeEventListener","$e9e2cf92950df0b951e7bac95d18$var$CollectionItemSlot","RovingFocusItem","aria-disabled","focusable","data-disabled","onMouseUp","onMouseMove","onMouseLeave","MenuItemNative","View","MenuCheckboxItem","checked","onCheckedChange","checkboxItemProps","$e9e2cf92950df0b951e7bac95d18$var$ItemIndicatorContext","Provider","aria-checked","getCheckedState","RadioGroupContext","MenuRadioGroup","onValueChange","groupProps","handleValueChange","useMemo","$e9e2cf92950df0b951e7bac95d18$var$RadioGroupContext","MenuGroup","MenuRadioItem","radioItemProps","useContext","_context$onValueChang","ITEM_INDICATOR_DEFAULT_TAG","ItemIndicatorContext","MenuItemIndicator","indicatorProps","Primitive","MenuAnchor","extendPrimitive","PopperPrimitive","Anchor","displayName","defaultProps","MenuLabel","MenuSeparator","aria-orientation","MenuArrow","Arrow","Group","Label","Item","Platform","OS","CheckboxItem","RadioGroup","RadioItem","ItemIndicator","Separator"],"version":3,"file":"index.module.js.map"}